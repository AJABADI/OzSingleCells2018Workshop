---
title: "Oz Single Cells 2018 Informatics Workshop"
author: "Anne Senabouth"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Oz Single Cells 2018 Informatics Workshop}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
devtools::load_all("~/CodeRepositories/ascend-dev")
```

## 1. Preparing the R Environment
Prior to the workshop, please set up your R environment. Feel free to skip
some steps if you have already done those steps.

### 1.1 R installation
Please follow the R installation instructions [here](https://mirror.aarnet.edu.au/pub/CRAN/).
If you are a Windows user, make sure you install Rtools. Please note the `ascend`
package requires R version >= 3.4.3. The latest version of R version 3.5.1 is 
best.

### 1.2 R programming environment
The workshop will be done in [RStudio](https://www.rstudio.com/products/rstudio/download/),
but feel free to set up your own R workspace.

### 1.3 Package Installations
You will need to install the following packages to run the development version
of `ascend`. Feel free to skip these steps if you already have these packages.

#### 1.3.1 Packages from CRAN
You can use the install.packages() to install the packages described in this 
section. The pcakages you require from this repository are as follows:

1. [devtools](https://cran.r-project.org/web/packages/devtools/index.html): This 
package will be used to load the development version of `ascend`.
2. [tidyverse](https://www.tidyverse.org/): This is a series of R packages 
for data science and visualisation. This will install packages such as dplyr,
ggplot2 and tidyr.
3. [data.table](https://github.com/Rdatatable/data.table/wiki/Installation):
Please follow the instructions on this page for your operating system.

Remaining packages can be installed as follows:

```{r install_cran, eval = FALSE}
# List of packages to install
cran_packages <- c("reshape2", "fields", "ggbeeswarm", "gridExtra", 
                   "dynamicTreeCut", "dendextend", "RColorBrewer",
                   "locfit", "KernSmooth")

# Easy command to install all at once
install.packages(cran_packages)
```

#### 1.3.2 Packages from Bioconductor
Bioconductor is a repository for R packages  related to the analysis and 
comprehension of high-throughput genomic data. It uses a separate set of 
commands for the installation of packages.

##### 1.3.2.1 Setting up Bioconductor
Use the following code to retrieve the latest installer from Bioconductor.

```{r setup_bioconductor, eval = FALSE}
## try http:// if https:// URLs are not supported
source("https://bioconductor.org/biocLite.R")
biocLite()
```

You can then install the Bioconductor packages using `biocLite`.

```{r bioconductor_packages, eval = FALSE}
bioconductor_packages <- c("Biobase", "BiocGenerics", "BiocParallel",
                           "SingleCellExperiment", "scater", "scran")

biocLite(bioconductor_packages)
```

##### 1.3.2.2 Differential expression packages
`ascend` provides wrappers for [DESeq](https://bioconductor.org/packages/release/bioc/html/DESeq.html) 
and [DESeq2](https://bioconductor.org/packages/release/bioc/html/DESeq2.html), 
so you may choose to add them to your installation. However, we will only be 
using DESeq for the workshop as DESeq2 will require more time than allocated 
for the workshop.

### 1.4 Installing 'ascend' via devtools
As `ascend` is still under development, we will use devtools to install the
package.

```{r install_ascend, eval = FALSE}
# Load devtools package
library(devtools)

# Use devtools to install the package
install_github("IMB-Computational-Genomics-Lab/ascend")

# Load the package in R
library(ascend)
```

## 2. Preparing the data for the workshop
This vignette will use the unprocessed data from the dataset featured in
the publication [Single cell RNA sequencing of stem cell-derived retinal ganglion cells](https://www.nature.com/articles/sdata201813#data-records) 
by [Daniszewski et al. 2018]().

This dataset consists of stem cell-derived retina ganglion cells that have been
separated into THY1-positive and THY1-negative cells via flow cytometry. This 
protein is a marker for pluripotency.

Please note that this data has been batch equalized with subsampling.

## 2.1 Loading the data into R
We will be bypassing the manual preparation of the data for this workshop. If 
you wish to know more about manually loading the data into R, please refer to 
the `ascend` vignettes.

Instead, we will use the `loadCellRanger` command to load the data into R. This
command parses the filtered data generated by Cell Ranger and assumes 
mitochondrial and ribosomal genes will be used as controls. It also parses 
batch information from the cell identifiers assigned by Cell Ranger's
batch aggregation function. Please note that this batch aggregation function
has also normalised the dataset via the subsampling method described 
by [Zheng et al. 2016](https://www.nature.com/articles/ncomms14049).

```{r load_data}
# Set path to data
data_dir <- "data/hIPSC_scRNA_Aggregated_Raw/outs/filtered_gene_bc_matrices_mex/GRCh38p7"
em_set <- loadCellRanger(data_dir)
```

We can review the contents of the EMSet by inputting the variable name of the
EMSet into the console.

```{r review_emset}
em_set
```

The summary shows how many genes are in the EMSet, what genes were set as 
controls and what is kept in the various slots of the EMSet. You may recognise
some of the slot names from somewhere - this is because this version of the
EMSet has inherited from the [SingleCellExperiment](https://bioconductor.org/packages/release/bioc/vignettes/SingleCellExperiment/inst/doc/intro.html#the-singlecellexperiment-class) superclass.

The EMSet differs from the SingleCellExperiment class in which it contains 
seperate slots for cell and gene-related metadata and additional slots for
cluster analysis and log information. Also, the EMSet generates a set of
quality control metrics based on the count matrix upon creation, and will
update the metrics everytime this matrix is changed.

We can review the cell information that is stored in the colInfo slot as follows:

```{r review_colinfo}
colInfo(em_set)
```

As you can see, the loadCellRanger function has extracted the batch identifiers
from the cell barcode labels. Batches 1 and 2 refer to THY1-positive and 
THY1-negative cells, respectively. 

## 3. Quality Control and Filtering
### 3.1 Assessing quality of the dataset
First, we will have a look at the quality of the dataset. Some quality control
metrics were generated when the EMSet was created; they are stored in the
`rowData` (metrics for genes) and `colData` (metrics for cells) slots. We can
visualise these values with quality control plots.

We can generate all the plots we will need for this step with with the
plotGeneralQC function.

```{r raw_qc}
qc_plots <- plotGeneralQC(em_set)
```

Other resources:
https://bioconductor.org/packages/release/workflows/vignettes/simpleSingleCell/inst/doc/work-2-umis.html
https://hemberg-lab.github.io/scRNA.seq.course/cleaning-the-expression-matrix.html#exprs-qc

The two plots below represent metrics related to the total number of UMIs 
mapped to a cell.

The first plot is a barplot that depicts the library size of each cell and is
coloured by the batch. This plot lets us quickly review the distribution of
library sizes and if there are any significant batch effects in the dataset.

The second plot is a histogram of library sizes, with library size on the x-axis
and number of cells with the library size on the y-axis. Please note that this 
dataset comprises of cells that have already been filtered from the background
based on a minimum threshold value for the number of UMIs present in the cell.
There are some cells with significantly larger numbers of UMIs - they may be
doublets where more than one cell ended up in a droplet. We will need to 
remove these cells.

```{r libsize_qc}
library(gridExtra)
grid.arrange(qc_plots$libsize_barplot, qc_plots$libsize_histogram, ncol = 1)
```

We also want to review the number of genes being expressed in each cell, and
what proportion of UMIs are mapped to top gene expressors. The first plot below
represents the number of cells expressing a number of genes. The number of
expressed genes will differ based on the cell type and other factors such 
as cell cycle phase.

The second plot represents the proportion of genes mapped to the top 500 most
expressed genes (y-axis) per sample, with each point representing the percentage
of expression contributed by the 100 most-expressed genes. 

```{r gene_qc}
grid.arrange(qc_plots$ngenes_hist, qc_plots$topgenes_violin, ncol = 1)
```

Some cells appear to be dominated by the expression of a small subset of genes. 
These genes may be mitochondrial and ribosomal genes. 

The plots below show the proportion of mitochondrial and ribosomal gene
expression to total expression. Some cells have a higher proportion of ribosomal
gene expression that can indicate they are of low quality, and should be 
removed from the dataset.

```{r control_qc}
grid.arrange(qc_plots$control_hists$Mt, qc_plots$control_hists$Rb, 
             qc_plots$control_violins$Mt, qc_plots$control_violins$Rb, ncol = 2)
```

### 3.2 Filtering low quality cells from the dataset
[Something about workflow...]

```{r filter_data}
# Filter library size and controls by MAD
filtered_set <- filterByOutliers(em_set, 
                                 cell.threshold = 3, 
                                 control.threshold = 3)

# Filter out cells based on proportion of control expression
filtered_set <- filterByControl(filtered_set, control = "Mt", pct.threshold = 20)
filtered_set <- filterByControl(filtered_set, control = "Rb", pct.threshold = 50)
filtered_set <- filterLowAbundanceGenes(filtered_set, pct.threshold = 1)
```

We can review which cells and genes were removed from the dataset by reviewing
the progress log.

```{r review_log}
progressLog(filtered_set)
```

We can also review the impact of QC on the dataset by regenerating the QC plots.

```{r review_qc_plots}
filtered_qc_plots <- plotGeneralQC(filtered_set)
```

```{r display_review_qc}
grid.arrange(filtered_qc_plots$libsize_barplot, filtered_qc_plots$libsize_histogram, 
             filtered_qc_plots$ngenes_hist, filtered_qc_plots$topgenes_violin,
             filtered_qc_plots$control_hists$Mt, filtered_qc_plots$control_hists$Rb, 
             filtered_qc_plots$control_violins$Mt, filtered_qc_plots$control_violins$Rb,
             ncol = 2)
```

### 4. Normalisation of data
We will normalise the data by Relative Log Expression.
```{r NormaliseByRLE}
norm_set <- normaliseByRLE(filtered_set)
norm_qc <- plotNormQC(norm_set)
```